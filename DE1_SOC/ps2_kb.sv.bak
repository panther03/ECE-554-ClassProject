/*
PS/2 Keyboard Device Driver
Aidan McEllistrem
3/30/23

Reads in PS/2 key presses
and transmits them to the
*/

module PS2_kb(
    input clk,                   // Will need to be divided to between 10kHz - 16kHz 
                                 // (so 12.5 is OK -- 50MHz / 12.5kHz = 4000 divisor)
    input rst_n,
    input PS2_CLK_i,             // The PS/2 KB has a clock of its own
    input PS2_DAT_i,             // Serial line in from the KB
    output reg [7:0] PS2_CHAR_o  // Last key pressed
    output reg PS2_rdy_o         // signal that a key code is available         
  );
  
  /*// Divided clock for reading PS/2 clk in
  reg [11:0] PS2_read_clk_timer;
  reg PS2_read_clk;
  
  always @(posedge clk, negedge rst_n) begin
    if (!rst_n)
      PS2_read_clk_timer <= 12'h000;
    else if (PS2_read_clk_timer < 12'd4000) begin
      PS2_read_clk_timer <= PS2_read_clk_timer + 1;
      PS2_read_clk <= PS2_read_clk;
    end
    else begin
      PS2_read_clk_timer <= 0;
      PS2_read_clk <= ~PS2_read_clk;
    end
  end*/
  
  reg [8:0] rx_data;
  wire rdy;
  
  UART_rx iPS2_UART_RX(
      .clk(clk), .rst_n(rst_n),
      .RX(PS2_DAT_i),
      .baud(13'd4000),
      .rx_data(rx_data),
      .rdy(rdy)
  );
  
  always @(posedge clk) begin
    if (rdy) begin
      // check parity bit to the data
      // parity bit should be odd!
      if (~^rx_data[7:0] == rx_data[8]) begin
        // transfer on success
        PS2_CHAR_o <= rx_data[7:0]
        PS2_rdy_o  <= 1;
      end
      // otherwise drop the packet
      else
        PS2_rdy_o <= 0;
    end
    else begin
      PS2_rdy_o <= 0;
    end
  end
  
  

endmodule